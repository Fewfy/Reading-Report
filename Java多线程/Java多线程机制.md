# Java多线程机制

参考自[Java的多线程机制系列](http://www.cnblogs.com/mengheng/p/3491304.html)

jdk5之前，实现多线程只有synchronized, Thread.sleep(), Object.wait/notify这些方法，并且synchronized方法效率特别低，因为这个是通过直接把没有获取锁的线程挂起实现的，而挂起之后需要重新调度，这个的花费远比执行这个线程高。

- 线程(感觉博客里面很多总结还是挺到位的, 就直接引用过来了)

  > 线程依附于进程，是进程分配资源最小的单位，一个进程有一个或多个线程。

  > 线程有就绪，阻塞和运行三种状态

  > 多线程并发环境，本质上是要解决两个问题，1. 线程之间如何通信; 2.线程之间如何同步

  即为了解决线程之间的正确通信的问题，多个线程对同一个数据进行修改应该如何处理，得到的结果是怎样的

- 锁

  Java的多线程是通过锁的概念来实现的。锁需要实现两个概念

  - 互斥性。当一个线程拥有某个对象锁时，其他的线程就不能再获得这个锁了，否则就会导致数据不一致
  - 可见性。线程在释放锁之前，对共享数据所做的修改，对于随后获得该锁的线程是可见的

  > 线程持有对象锁的目的并不仅仅是为了拿着，而是表明拥有了某段代码段的执行权力，别的线程没拿到对象锁就无法执行共享代码

- 挂起、休眠、阻塞和非阻塞

  - 挂起。线程失去CPU的使用，直到被其他的线程唤醒
  - 休眠。线程失去CPU的使用，但是不会释放锁，可以视作自己会恢复(实质上是由守护进程唤醒)
  - 阻塞。线程没有拿到某个资源，线程会被挂起，直到能够拿资源
  - 非阻塞。如果没有拿到资源，会继续执行其他的事情，而不是整个线程都被挂起

  Java中的wait和notify的前提都是要获得了锁，然后在wait期间又会释放掉锁，所以执行wait和notify的方法时，需要加锁。

- 内核态和用户态

  Java没有实现线程模型，而是直接沿用了操作系统的线程模型，也就是线程的分配，锁定，创建和销毁都是需要Java自己来做的(Java1.2之前是实现了线程模型的，后面就放弃了)，所以在Java中频繁的执行线程调度和挂起会严重影响效率。

- 总线锁定和缓存一致性

  总线是所有CPU和芯片组连接的主干道，负责CPU和外界所有部件的通信。如果某个CPU在总线上发送***LOCK***信号，然后其他的CPU就不会缓存该共享变量内存地址的缓存。

  > 缓存一致性机制整体来说，是当某块CPU对缓存中的数据进行操作了之后，就通知其他CPU放弃储存在他们内部的缓存，或者从主存中重新读取

- CAS(Compare and Swap)

  将指定的内存地址的内容和所给的某个值相比，如果相等，则将其内容替换为指令中提供的新值，否则更新失败。

  多个线程尝试使用CAS去更新同一个变量，只有其中一个线程能够更新变量，而其他的线程都会失败，如果用synchronized机制，这些失败的线程就需要挂起，而CAS这些不会被挂起而是被告知这次失败了，可以下一次尝试。可以大大提高线程效率。

- 内存屏障

  禁止流水线的并行操作，会导致效率变差

- synchronized同步原理


  > synchronized关键字是JDK5之前实现锁的唯一途径(volatile关键字能保证可见性，但不能保证互斥性)，其在字节码上编译为monitorenter和monitorexit这样的JVM层次的原语。
  >
  > ....
  >
  > 被阻塞的线程会被挂起、等待重新调度，也就是如前面“用户态和内核态”所说的，在两个态之间，来回切换，对性能有较大影响。

  JDK5之后引入了CAS操作，也就是说被阻塞的线程不需要被挂起，JDK6的时候还增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略。

- 锁的内存结构

  > 锁是一个逻辑抽象，其实是一种机制

  每个对象都有两个字宽的字节头(数组对象有3个，一个字宽等于4个字节)，对象头的最后两位存储了锁的标志位，01是初始状态，随着锁级别的不同，对象头里存储不同的内容，偏向锁存储的是当前占用此对象的线程ID ; 轻量级记录的是指向线程栈中锁记录的指针 ; 重量锁记录的指向重量级锁的指针;

- 锁的级别

  - 偏向锁

    由于大部分时间，持有锁的都是那么几个线程，所以，在一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录中记录这个线程的ID，以后该线程需要获得对象锁时，只需要比较对象头里是否存储有当前线程的ID，如果是直接使用，如果不是的，该锁去检测持有该锁的线程是否还活着，如果是，该锁被升级为轻量级锁，但依然是该线程持有锁，并且记录里面不再是存储线程ID，而是指向锁记录地址的指针;如果线程已经死亡，那么开放竞争。

  - 轻量级锁

    对于轻量级的锁，如果线程想进入同步代码块的时候，都得通过CAS尝试将对象头中的锁指针替换为自身栈中的记录。如果没有成功，就一直自旋，直到升级成重量级锁。

  - 重量级锁

    被挂起，需要被重新调度

  ​